\chapter{Conceptes bàsics}

\section{Clustering}

\subsection{Introducció}

En termes generals un cluster és un grup de sistemes independents que treballen
junts com un sistema únic. El client interactua amb un cluster com si fós un
servidor únic. Les configuracions de cluster s'utilitzen per a tenir
disponibilitat i escalabilitat:

\begin{description}
\item[Disponibilitat:]
Quan un sistema falla en el cluster, el programari del cluster respon
distribuint el treball del sistema que ha fallat als sistemes que queden en el
cluster.

\item[Escalabilitat:]
Quan la càrrega general excedeix les capacitats dels sistemes en el cluster, és
possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients
que planegen ampliar la capacitat del seu sistema han de considerar servidors
"high end" costosos que proporcionen espai per a CPUs, controladors i memòria
addicionals. Al utilitzar la tecnologia de clustering, els clients podran
afegir gradualment sistemes estàndards més petits, segons sigui necessari, per a
satisfer els requeriments generals de potència de processament.
\end{description}


\subsection{Diferents implementacions}
A continuació passarem a descriure per sobre algunes de les diferents
implementacions existents en alguns sistemes operatius, les quals representen
diferents paradigmes.


\subsubsection{Linux}

\begin{itemize}
\item \textbf{OpenMosix:}
És una implementació basada en la distribució de processos, com a modificació
per al nucli, de forma que el procés és totalment transparent a l'usuari (al
programador* de l'aplicació), cosa que fa molt més portables els programes a
d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades
específicament per a executar-se en un cluster.

De totes maneres, per tal de poder paral·lelitzar les aplicacions, aquestes han
d'haver estat ja programades amb diversos processos, ja que OpenMosix no
paral·lelitza aplicacions, sinó que només distribueix la càrrega entre els
diferents nodes.

Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol
procés), tardarà el mateix que si només tinguéssim un node; però si executem deu
programes d'aquests, tardaran el que si només n'executéssim un, ja que cadascun
s'executarà en un node.

Un inconvenient, però, és que tots els nodes del cluster han de tenir exactament
el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap
enrere).

Un altre dels problemes de OpenMosix, és que no pot migrar cap procés que
comparteixi memòria, de forma que tampoc podrà migrar threads, ja que aquests
comparteixen memòria.


\item \textbf{Beowulf:}
\nocite{Beowulf-Home}
\nocite{Beowulf-Howto}
Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
pot dir que un sistema és Beowulf només si està construït de la mateixa forma que
la màquina original de la NASA; d'altres van cap a l'altre extrem i diuen que és
un sistema Beowulf tot aquell conjunt de màquines que corren codi paral·lel), és
una arquitectura multi-computador que pot ser utilitzada per a fer computacions
en paral·lel. Normalment consisteix en un node servidor i un o més nodes
connectats via Ethernet (o qualsevol altre xarxa), però el millor de tot és que
es pot construir amb hardware "normal", com per exemple qualsevol PC que pugui
utilitzar Linux, adaptadors estàndard d'Ethernet i switchos. Beowulf també
utilitza software "comú", com el sistema operatiu Linux, PVM (Parallel Virtual
Machine) i MPI (Message Passing Interface). Una de les grans diferències entre
Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) és
el fet de què Beowulf es comporta com una única màquina més que no mas com un
conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un
paquet de CPU + memòria que es pot connectar al cluster, tal com una CPU o un
mòdul de memòria es poden connectar a una placa base.

Beowulf no és un paquet de software especial, una nova topologia de xarxa o
l'últim hack per al kernel, sinó que és una tecnologia de clustering de màquines
Linux per a formar un supercomputador paral·lel virtual. Tot i que hi ha varis
paquets de software com modificacions per al kernel, llibreries PVM i MPI i
eines de configuració que fan l'arquitectura Beowulf més ràpida, més fàcil de
configurar i molt més usable, un pot construïr una màquina de la classe Beowulf
utilitzant distribucions de Linux estàndards sense cap software addicional.
Tenint un parell de màquines linux en xarxa que comparteixen com a mínim el
/home a través de NFS i es confien l'una a l'altra per executar shells remotes
(rsh), es podria dir que es té una màquina Beowulf molt simple de dos nodes.

Així doncs, està clar que una aplicació, per a funcionar en una arquitectura
Beowulf, ha d'haver estat escrita utilitzant llibreries o mètodes
especialitzats, no transparents a l'usuari, però ofereix més rendiment que, per
exemple, OpenMosix (tot i que aquest últim és totalment transparent a l'usuari).



\item \textbf{Altre software de clustering:}
Tot i buscar per Internet la existència d'altre software de clustering, no hem trobat res excepte distribucions basades en el software que ja hem comentat.
\end{itemize}


\subsubsection{Microkernels (Mach/L4)}

No existeix cap eina suficientment madura sobre microkernels que ens ofereixi
tot el que tenim en altres sistemes com Linux. Tot i això si que es poden
trobar alguns projectes d'investigació que fan referència a la construcció de
sistemes de clustering sobre microkernels. Hem trobat dos exemples:

Hurricane Operating System, clúster experimental orientat a la investigació i
la recerca \cite{Microkernel-HOS}.

CHORUS/Fusion per SCO Sopen Menystens Software is una implementació
multi-servidor per SCO UNIX. Aquest entend SCO Unix amb funcionalitats de
temps real i clustering.


\subsubsection{Altres Sistemes Operatius}

\begin{itemize}
\item {\textbf{Solaris:}}
Hem trobat exemples de clústers de computació construïts amb aquest Sistema
Operatiu, per exemple, el SciClone Cluster Project \cite{AltresSO-SciCLone}.
El clúster està format exclusivament per màquines Sun però no donen moltes
característiques del sistema operatiu, ni tampoc si han tingut que desenvolupar
un afegit per dona suport per clustering.

\item {\textbf{MacOSX:}}
Utilitzant la bibloteca de processament carbonlib més un software de clustering
anomenat pooch \cite{AltresSO-MacOS} es pot crear un cluster amb
aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
clustering està basat en l'ús de biblioteques de paral·leliització i per tant
els programes s'hauran d'escriure pensant que s'executen en un cluster no és
transparent a l'usuari/aplicació.
\end{itemize}


\section{Abstraccions existents en Sistemes de Fitxers}

\subsection{Translators de Hurd}
\nocite{Hurd-Translators}
Els translators són servidors de Hurd (SO basat en el micronucli gnuMach, tot i
que s'està migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
la interfícies bàsica del sistema de fitxers, de manera que es poden inserir
entre el contingut real d'un fitxer (entenent com a fitxer la representació
corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
en una altra màquina o, fins i tot, no ser cap fitxer, sinó la representació
d'una zona de memòria) i l'usuari que accedeix al fitxer, de forma que
\textit{tradueix} les peticions de l'usuari.

Els translators, a més amés, tenen unes propietats molt interessants, i és que
des del punt de vista del kernel, no són més que processos d'usuari, de forma
que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
superusuari per instal·lar o modificar un translator, l'únic que fa falta és
tenir drets d'accés a l'inode sobre s'uneix el translator. Molts translators no
requereixen un fitxer per a funcionar, i és per això que la informació sobre
aquests es guarda a l'inode.

Els translators són responsables de servir totes les operacions del sistema de
fitxers que fan referència a l'inode al que s'uneix. Per això, al no estar
restringits al típic conjunt d'objectes (fitxer de dispositiu, link, etc.), són
lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
exemple podria ser un translator que es comportés com un directori quan fos
accedit per \texttt{cd} o \texttt{ls} però que al mateix temps es comportés com
un fitxer al ser accedit per \texttt{cat}.


\subsection{/proc de Linux}

\subsubsection {Introducció a /proc}

Linux manté una abstracció de sistema de fitxers virtual anomenada /proc. En
diem abstracció, perquè realment no és ben bé un sistema de fitxers implementat
sobre VFS com ho poden ser: Ext2, Ext3, ReiserFS, Minix...
A més /proc en podem dir que és un pseudo-sistema de fitxers, ja que en realitat
cap dels fitxers o directoris que s'hi visualitzen existeixen realment.

/proc és realment un mirall on s'hi veuen reflectides algunes de les
estructures del nucli del sistema operatiu, i per mitjà del qual podem
controlar alguns paràmetres de seguretat tan fàcilment com resulta interactuar
amb sistema de fitxers real.


\subsubsection {Més sobre /proc}

/proc està disponible en el sistema operatiu Linux quan el nucli es compila amb
la opció CONFIG\_PROC\_FS=Y. També haurem de seleccionar la opció
CONFIG\_SYSCTL=Y per a poder modificar el valor de determinats paràmetres.
La majoria de distribucions inclouen nuclis compilats amb aquesta opció i en
general és aconsellable seleccionar-la en el moment de recompilar el nucli.

\subsubsection {Com es munta?}

El pseudo-sistema de fitxers /proc es pot muntar automàtic en el moment
d'iniciar el sistema indicant-ho a /etc/fstab. En el cas que sigui necessari
muntar-lo manualment utilitzaríem la següent comanda:

\begin{quotation}
\verb"mount -t proc proc /proc"
\end{quotation} 

És aconsellable que /proc sigui muntat automàticament al sistema.
En cas de no disposar del suport per a /proc, alguns programes d'administració
del sistema (com per exemple el que nosaltres estem desenvolupant) no
funcionaran ja que no podrem modificar/accedir en temps d'execució a alguns
paràmetres del nucli del sistema operatiu (molts d'ell de seguretat).

\subsubsection {Què conté /proc?}
Dins del directori /proc hi trobem dos tipus bàsics d'informació.
En primer lloc, per a cada procés actiu existeix un directori.
Dins del directori de cada procés hi ha diversos fitxers així com un
subdirectori d'informació específica del procés (paràmetres passats per línia de
comandes, enllaç al directori actual del procés, variables d'entorn dins del
context del procés, els descriptors de fitxers oberts pel procés, mapa i
informació sobre la utilització de la memòria...).

Adicionalment, existeixen una sèrie de directoris amb informació sobre els
diferents mòduls del sistema operatiu. O tal i com veurem en aquest treball,
OpenMosix proporciona un subdirectori (hpc) dins de /proc en el qual hi trobarem
alguns fitxers que ens seran de gran utilitat per a implementar les
funcionalitats que defineixen el nostre projecte.

Al fitxer proc.txt (disponible al directori de documentació de sistemes de
fitxers del codi font del nucli de Linux) hi ha informació detallada de tot el
que podem trobar dins de /proc.
Un altre document d'interès és ip-sysctl.txt, disponible al directori de
documentació sobre treball en xarxa.

No tots els paràmetres existents en /proc són modificables directament per
l'usuari. De fet, la majoria són valors de només lectura i altres són molt
millor controlar-los per mitjà del nucli amb la utilització de les divers
funcions i eines existents al sistema.


\subsubsection {Exemples de directoris}
/proc/sys/net/ipv4 

Dins d'aquest directori tenim disponibles una sèrie de fitxers amb els valors i
paràmetres del protocol IP versió 4. Es tracta d'una sèrie de valors directament
emprats pel nucli del sistema operatiu en les comunicacions TCP/IP basades en el
protocol IP versió 4.

Per determinar el valor d'algun d'aquests paràmetres, l'única cosa que hem de
fer és mirar el seu contingut. Per exemple:

\begin{quotation}
\verb"$ cat /proc/sys/net/ipv4/icmp_echo_ignore_all"

\verb"0"
\end{quotation} 

Ens mostra que actualment el sistema operatiu té assignat el valor 0
(desactivat) al paràmetre ICMP\_ECHO\_IGNORE\_ALL.

L'usuari \textit{root} del sistema té el privilegi de modificar el valor
d'aquesta variable:

\begin{quotation}
\verb"# echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all"
\\
\verb"# cat /proc/sys/net/ipv4/icmp_echo_ignore_all"

\verb"1"
\end{quotation} 

Més endavant, als apartats d'implementació amb OpenMosix, veurem com també
podríem editar paràmetres de fitxers del subdirectori que ofereix per a
realitzar algunes de les funcions que ens proporciona (ex: Bloquejar un node per
rebre processos remots)


\subsection{Altres abstraccions en SFs}

Com que en Linux tots els sistemes de fitxers, virtuals i no virtuals, estan basats en el VFS, no hem trobat res en aquest sistema.

Emperò tampoc hem trobat res en d'altres sistemes, excepte els translators que ja hem comentat per a GNU/Hurd, de manera que no hem aconseguit trobar res per encabir en aquesta secció.