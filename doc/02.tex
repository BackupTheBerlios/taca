\documentclass{letter}

%%%%%%%%%% Start TeXmacs macros
\catcode`\à=\active \defà{\`a} \catcode`\À=\active \defÀ{\`A}
\catcode`\á=\active \defá{\'a} \catcode`\Á=\active \defÁ{\'A}
\catcode`\ä=\active \defä{\"a} \catcode`\Ä=\active \defÄ{\"A}
\catcode`\â=\active \defâ{\^a} \catcode`\Â=\active \defÂ{\^A}
\catcode`\å=\active \defå{{\aa}} \catcode`\Å=\active \defÅ{{\AA}}
\catcode`\ç=\active \defç{\c{c}} \catcode`\Ç=\active \defÇ{\c{C}}
\catcode`\è=\active \defè{\`e} \catcode`\È=\active \defÈ{\`E}
\catcode`\é=\active \defé{\'e} \catcode`\É=\active \defÉ{\'E}
\catcode`\ë=\active \defë{\"e} \catcode`\Ë=\active \defË{\"E}
\catcode`\ê=\active \defê{\^e} \catcode`\Ê=\active \defÊ{\^E}
\catcode`\ì=\active \defì{\`{\i}} \catcode`\Ì=\active \defÌ{\`{\I}}
\catcode`\í=\active \defí{\'{\i}} \catcode`\Í=\active \defÍ{\'{\I}}
\catcode`\ï=\active \defï{\"{\i}} \catcode`\Ï=\active \defÏ{\"{\I}}
\catcode`\î=\active \defî{\^{\i}} \catcode`\Î=\active \defÎ{\^{\I}}
\catcode`\ò=\active \defò{\`o} \catcode`\Ò=\active \defÒ{\`O}
\catcode`\ó=\active \defó{\'o} \catcode`\Ó=\active \defÓ{\'O}
\catcode`\ö=\active \defö{\"o} \catcode`\Ö=\active \defÖ{\"O}
\catcode`\ô=\active \defô{\^o} \catcode`\Ô=\active \defÔ{\^O}
\catcode`\ù=\active \defù{\`u} \catcode`\Ù=\active \defÙ{\`U}
\catcode`\ú=\active \defú{\'u} \catcode`\Ú=\active \defÚ{\'U}
\catcode`\ü=\active \defü{\"u} \catcode`\Ü=\active \defÜ{\"U}
\catcode`\û=\active \defû{\^u} \catcode`\Û=\active \defÛ{\^U}
\catcode`\ý=\active \defý{\'y} \catcode`\Ý=\active \defÝ{\'Y}
\catcode`\ÿ=\active \defÿ{\"y} \catcode`\˜=\active \def˜{\"Y}
\catcode`\½=\active \def½{!`}
\catcode`\¾=\active \def¾{?`}
\catcode`\ß=\active \defß{{\ss}}
\newcommand{\chapter}[1]{\medskip\bigskip

\noindent\textbf{\begin{center}\huge #1\end{center}}\vspace{-3ex}

\noindent}
\newcommand{\section}[1]{\medskip\bigskip

\noindent\textbf{\LARGE #1}\vspace{-3ex}

\noindent}
\newcommand{\subsection}[1]{\medskip\bigskip

\noindent\textbf{\Large #1}\vspace{-3ex}

\noindent}
\newcommand{\paragraph}[1]{\smallskip

\noindent\textbf{#1} }
\newcommand{\subsubsection}[1]{\medskip\bigskip

\noindent\textbf{\large #1}\vspace{-3ex}

\noindent}
\newcommand{\tmstrong}[1]{\textbf{#1}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

\chapter{Conceptes bàsics}

\section{Clustering}

\subsection{Introducció}

\paragraph{En termes generals un cluster és un grup de sistemes independents
que treballen junts com un sistema únic. El client interactua amb un cluster
com si fós un servidor únic. Les configuracions de cluster s'utilitzen per a
tenir disponibilitat i escalabilitat:}{\begin{description}
  \item[Disponibilitat:] Quan un sistema falla en el cluster, el programari
  del cluster respon distribuint el treball del sistema que ha fallat als
  sistemes que queden en el cluster.
  
  \item[Escalabilitat:] Quan la càrrega general excedeix les capacitats dels
  sistemes en el cluster, és possible afegir sistemes addicionals al mateix.
  En l'actualitat, els clients que planegen ampliar la capacitat del seu
  sistema han de considerar servidors "high end" costosos que proporcionen
  espai per a CPUs, controladors i memòria addicionals. A l'utilitzar la
  tecnologia de clustering, els clients podran afegir gradualment sistemes
  estàndars més petits, segons sigui necessari, per a satisfer els
  requeriments generals de potència de processament.
\end{description}}

\subsection{Diferents implementacions}

A continuació passarem a descriure per sobre algunes de les diferents
implementacions existents en alguns sistemes operatius, les quals representen
diferents paradigmes.

\paragraph{\subsubsection{[}Hola]Linux}{\begin{itemize}
  \item \textbf{OpenMosix:} És una imlpementació basada en la distribució de
  processos, com a modificació per al nucli, de forma que el procés és
  totalment transparent a l'usuari (al programador* de l'aplicació), cosa que
  fa molt més portables els programes a d'altres sistemes, utilitzin o no
  OpenMosix, i des d'aplicacions no dissenyades específicament per a
  executar-se en un cluster.
  
  De totes maneres, per tal de poder paral·lelitzar les aplicacions, aquestes
  han d'haver estat ja programades amb diversos processos, ja que OpenMosix no
  paral·lelitza aplicacions, sinó que només distribueix la càrrega entre els
  diferents nodes.
  
  Per exemple, si tenim deu nodes al cluster i executem un programa (amb un
  sol procés), tardarà el mateix que si només tinguéssim un node; però si
  executem deu programes d'aquests, tardaran el que si només n'executéssim un,
  ja que cadascun s'executarà en un node.
  
  Un inconvenient, però, és que tots els nodes del cluster han de tenir
  exactament el mateix nucli (sense compatibilitat de versions ni cap endavant
  ni cap enrere).
  
  Un altre dels problemes de OpenMosix, és que no pot migrar cap procés que
  comparteixi memòria, de forma que tampoc podrà migrar threads, ja que
  aquests comparteixen memòria.
  
  \item \textbf{Beowulf:} {\nocite{Beowulf-Home}} {\nocite{Beowulf-Howto}}
  Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen
  que es pot dir que un sistema és Beowulf només si està contruït de la
  mateixa forma que la màquina original de la NASA; d'altres van cap a l'altre
  extrem i diuen que és un sistema Beowulf tot aquell conjunt de màquines que
  corren codi paral·lel), és una arquitectura multi-computador que pot ser
  utilitzada per a fer computacoins en paral·lel. Normalment consisteix en un
  node servidor i un o més nodes connectats via Ethernet (o qualsevol altre
  xarxa), però el millor de tot és que es pot construïr amb hardware "normal",
  com per exemple qualsevol PC que pugui utilitzar Linux, adaptadors estàndar
  d'Ethernet i switchos. Beowulf també utilitza software "comú", com el
  sistema operatiu Linux, PVM (Parallel Virtual Machine) i MPI (Message
  Passing Interface). Una de les grans diferències entre Beowulf i un cluster
  de estacions de treball (COW - Cluster of Workstations) és el fet de què
  Beowulf es comporta com una única màquina més que no mas com un conjunt
  d'estacions de treball. Els nodes de Beowulf es poden pensar com un paquet
  de CPU + memòria que es pot connectar al cluster, tal com una CPU o un mòdul
  de memòria es poden connectar a una placa base.
  
  Beowulf no és un paquet de software especial, una nova topologia de xarxa o
  l'últim hack per al kernel, sinó que és una tecnologia de clustering de
  màquines Linux per a formar un supercomputador paral·lel virtual. Tot i que
  hi ha varis paquets de software com modificacions per al kernel, llibreries
  PVM i MPI i eines de configuració que fan l'arquitectura Beowulf més ràpida,
  més fàcil de configurar i molt més usable, un pot construïr una màquina de
  la classe Beowulf utilitzant distribucions de Linux estàndars sense cap
  software addicional. Tenint un parell de màquines linux en xarxa que
  comparteixen com a mínim el /home a través de NFS i es confien l'una a
  l'altra per executar shells remotes (rsh), es podria dir que es té una
  màquina Beowulf molt simple de dos nodes.
  
  Així doncs, està clar que una aplicació, per a funcionar en una arquitectura
  Beowulf, ha d'haver estat escrita utilitzant llibreries o mètodes
  especialitzats, no transparents a l'usuari, però ofereix més rendiment que,
  per exemple, OpenMosix (tot i que aquest últim és totalment transparent a
  l'usuari).
  
  De totes maneres,
  
  \item \textbf{...Altre soft de clustering...}
\end{itemize}}

\subsubsection{Microkernels (Mach/L4)}

No existeix cap eina suficientment madura sobre microkernels que ens ofereixi
tot el que tenim en altres sistemes com Linux. Tot i això si que es poden
trobar alguns projectes d'investigació que fan referència a la construcció de
sistemes de clustering sobre microkernels. Hem trobat dos exemples:

Hurricane Operating System, clúster experimental orientat a la investigació i
la recerca. Paper ftp://ftp.cs.toronto.edu/pub/paral·lel/Tumoral \_ Untau \_
Caboriege \_ USENIX92.ps.Z

CHORUS/Fusion per SCO Sopen Menystens Software is una implementació
multi-servidor per SCO UNIX. Aquest entend SCO Unix amb funcionalitats de
temps real i clustering.

\subsubsection{Altres Sistemes Operatius}

\begin{itemize}
  \item {\tmstrong{Solaris}}: Hem trobat exemples de clústers de computació
  construïts amb aquest Sistema Operatiu, per exemple, el SciClone Cluster
  Project. El clúster està format exclusivament per màquines Sun però no donen
  moltes característiques del sistema operatiu, ni tampoc si han tingut que
  desenvolupar un afegit per dona suport per clustering.
  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
  
  \item {\tmstrong{MacOSX:}} Utilitzant la bibloteca de processament carbonlib
  més un software de clustering anomenat pooch
  (http://daugerresearch.com/pooch/) és pot crear un cluster amb aquest
  sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
  clustering està basat en l'ús de biblioteques de paral.leliització i per
  tant els programes s'haurán d'escriure penssant que s'executen en un cluster
  no és transparent a l'usuari/aplicació.
\end{itemize}

\section{Abstraccions existents en Sistemes de Fitxers}

\subsection{Translators de Hurd} {\nocite{Hurd-Translators}} Els translators
són servidors de Hurd (SO basat en el micronucli gnuMach, tot i que s'està
migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen la
interfícies bàsica del sistema de fitxers, de manera que es poden insertar
entre el contingut real d'un fitxer (entenent com a fitxer la representació
corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot
estar en una altra màquina o, fins i tot, no ser cap fitxer, sinó la
representació d'una zona de memòria) i l'usuari que accedeix al fitxer, de
forma que \textit{tradueix} les peticions de l'usuari.

Els translators, a més amés, tenen unes propietats molt interessants, i és que
des del punt de vista del kernel, no són més que processos d'usuari, de forma
que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
superusuari per instal·lar o modificar un translator, l'únic que fa falta és
tenir drets d'accés a l'inode sobre s'uneix el translator. Molts translators
no requereixen un fitxer per a funcionar, i és per això que la informació
sobre aquests es guarda a l'inode.

Els translators són responsables de servir totes les operacions del sistema de
fitxers que fan referència a l'inode al que s'uneix. Per això, al no estar
restringits al típic conjunt d'objectes (fitxer de dispositiu, link, etc.),
són lliures de retornar qualsevol cosa que tingui sentit per al programador.
Un exemple podria ser un translator que es comportés com un directori quan fós
accedit per \texttt{cd} o \texttt{ls} però que al mateix temps es comportés
com un fitxer al ser accedit per \texttt{cat}.

\subsection{/proc de Linux vs. VFS de Linux}

\subsection{...Altres abstraccions en SFs...}

\end{document}
