\nocite{lkAPI}

\chapter {Detalls d'implementació}

Per a fer la nostra implementació, hem escollit el \textit{disseny complex}.

Hem pres aquesta decisió perquè partint d'un escenari Linux-OpenMosix, no veiem
viables les altres opcions perquè des de dins del propi kernel no es poden
executar aplicacions d'usuari com les OpenMosix Tools (\textit{disseny simple})
ni enllaçar amb les llibreries corresponents (\textit{disseny intermig}), que
en el cas de OpenMosix, no són tals, sinó crides a sistema, que tampoc és
possible utilitzar des de dins el kernel.

Més tard, explicarem que les altres dues opcions realment si que són possibles.

A l'hora de crear la implementació, hem pensat en un objectiu molt concret per
tal de reduir el tamany de la implementació (doncs fer-la completa requereix
molt de temps i no és l'objectiu d'aquesta pràctica).

Ens hem fixat com a objectiu la migració de processos entre nodes perquè és el
tret més significatiu del nostre programa.

Partint d'aquest objectiu hem estudiat quines són les mínimes parts necessàries
a implementar tant en el \textit{frontend} com en el \textit{backend}, pensant
que el projecte pugui ser ampliable a la resta del disseny que hem planificat.

Així doncs, el que hem implementat és un \textbf{mòdul del kernel} que conté les
següents parts.


\section{Frontend: sistema de fitxers virtual}

\nocite{VFS-overview}
\nocite{VFS-kmp}
\nocite{VFS-lki}
\nocite{VFS-libfs}
\nocite{VFS-rkfs}
\nocite{VFS-lk}
\nocite{VFS-tlk}
Aquest sistema de fitxers està basat en la interfície del VFS (\textit{Virtual
File System}) que proporciona Linux.

Al ser un sistema de fitxers virtual, tota la informació mostrada es genera de
forma dinàmica amb les dades obtingudes del \textit{backend}.

Bàsicament, en iniciar-se el mòdul, es registra el nostre sistema de fitxers:
\textit{tacafs}. I es desenregistra en descarregar el mòdul.

\begin{codi}
static int __init tacafs_init(void)
\{
   [...] return register_filesystem(&tacafs_type);
\}

static void __exit tacafs_exit(void)
\{
   unregister_filesystem(&tacafs_type); [...]
\}
\end{codi}

Seguidament a carregar el mòdul, ja es pot muntar el sistema de fitxers allà on
es vulgui, de forma que es crida a la operació que omple les dades del
\textit{super bloc}, que li associa l'inode que representa l'arrel del sistema
de fitxers.

Les funcions de més interès són les que van associades als fitxers i directoris.

Sobre els directoris, les funcions més destacables són:

\begin{description}
\item [file\_operations.readdir:]
Genera els continguts que es veuen en llegir els continguts d'un directori (per
exemple, els noms de fitxers, directoris i els seus permisos en fer un
\texttt{ls}).

En el següent codi (\texttt{frontend/linux/*.c}) generem el contingut per al directori
arrel, que llista els clusters que hi ha al sistema. En la resta de directoris es
faria de forma anàloga però canviant les crides al \textit{backend}.

\begin{codi}
int tacafs_f_readdir (struct file *file, void *dirent,
                      filldir_t filldir )
\{
   [...]
   if(filldir(dirent, ".", 1, file->f_pos++, de->d_inode->i_ino,
              DT_DIR)
      ||
      filldir(dirent, "..", 2, file->f_pos++,
              de->d_parent->d_inode->i_ino, DT_DIR))
      return 0;
   [...]
   num = num_clusters();                    // CRIDA AL BACKEND
   [...]
   if (llistar_clusters(llista, num) > 0) \{ // CRIDA AL BACKEND
       num = 0;
       while (llista != NULL) \{
           if(filldir(dirent, llista->nom, strlen(llista->nom),
	              file->f_pos++, INO(++num,INODE_CLUSTER), DT_DIR))
                return 0;
           llista = llista->next;
       \}
   \}
   [...]
\}
\end{codi}

\item [inode\_operations.lookup:]
Donada una estructura dentry, que en el VFS de Linux és l'encarregade de
representar la jerarquia de fitxers, i el inode pare al que pertany el dentry,
crea un inode, li associa les operacions corresponents, el mode i finalment
associa l'inode al dentry (la major part d'aquesta tasca la duu a terme la
funció \verb"tacafs_fill_dentry" i les que aquesta crida).

Aquesta funció seria cridada en accedir al directori en qüestió.

\begin{codi}
struct dentry *tacafs_i_lookup (struct inode *parent_inode,
                                struct dentry *dentry)
\{
    struct dentry *res = ERR_PTR(-ENOENT);
    struct cluster_t cluster;
    
    if (!obtenir_cluster(dentry->d_name.name, &cluster))
        goto out;
    /*
     * Hem de generar el inode per mostrar un cluster (el dentry)
     * Per tant un directori
     */
    res = tacafs_fill_dentry(parent_inode->i_sb, dentry, INODE_CLUSTER,
            MODE_DIR, &cluster, sizeof(cluster), &tacafs_cluster_iops,
            &tacafs_cluster_dops, &tacafs_cluster_fops);
out:
    return res;
\}

struct dentry *tacafs_fill_dentry (struct super_block *sb,
         struct dentry *dentry, int inobase, int mode, void *data,
	 int datasize, struct inode_operations *iops, 
	 struct dentry_operations *dops, struct file_operations *fops)
\{
    [...]
    inode = tacafs_make_inode(sb, INO(name2ino,inobase), mode,
	                      iops, fops);
    if (!inode)
	return ERR_PTR(-ENOMEM);

    dentry->d_op = dops;

    if (!tacafs_write_data(inode, data, datasize)) \{
	iput(inode);
	return ERR_PTR(-ENOMEM);
    \}

    d_add(dentry, inode);

    return NULL;
\}
\end{codi}
\end{description}

En quant als fitxers, les operacions que duu associades són el \texttt{lookup},
que duu a terme la mateixa tasca que en el cas dels directoris, el \texttt{read}
i el \texttt{write} que són els encarregats de llegir i escriure els continguts
del fitxer i el \texttt{rename} que és l'encarregat de tractar amb el moviment
de fitxers i directoris.

Les funcions \texttt{read} i \texttt{write} no ens ha calgut implementar-les per
l'objectiu que ens hem fixat.

La funció clau per a la migració de processos és \texttt{rename}, però no la hem
pogut arribar a implementar degut a què ens hem trobat una sèrie de problemes
que ens han portat molt de temps per trobar-hi solució a l'hora d'implementar el
\textit{backend} d'OpenMosix que explicarem tot seguit.


\section{Backend: adaptació al sistema de clustering}

\subsection{Definició de la interfície}

Partint dels objectius que ens hem fixat, hem definit una interfície genèrica
(fitxer \linebreak \texttt{backend/backend.h}) per a tractar des del 
\textit{frontend} amb el \textit{backend}.

Aquesta interfície consta d'unes operacions necessàries per a generar
l'estructura del sistema de fitxers:

\begin{codi}
int num_clusters ();
int llistar_clusters (struct cluster_t *llista, int maxnum);
int obtenir_cluster (const char *nom, struct cluster_t *cluster);
int cluster_valid (struct cluster_t *cluster);

int num_nodes (struct cluster_t *cluster_id);
int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista,
                   int maxnum);
int obtenir_node (struct cluster_t *cluster_id, const char *nom,
                  struct node_t *node);
int node_valid (struct node_t *node);

int num_procs (struct node_t *node_id);
int llistar_procs (struct node_t *node_id, struct proces_t *lista,
                   int maxnum);
int obtenir_proc (struct node_t *node_id, const char *nom,
                  struct proces_t *proces);
int proc_valid (struct proces_t *proces);
\end{codi}

I una sèrie de funcions per a dur a terme les funcionalitats que hem definit:

\begin{codi}
int migrar (struct proces_t  *proces, struct node_t *node_desti);

/* El node pot rebre procs. nous ? */
int node_bloquejat_rebre (struct node_t *node);

/* El node pot enviar procs. nous ? */
int node_bloquejat_enviar (struct node_t *node);

/* El proces no es pot migrar */
int proces_bloquejat (struct proces_t *proc);
\end{codi}


\subsection{Implementacions de la interfície}

\subsubsection{Exemple \textit{dummy}}

Primerament hem implementat un petit \textit{backend} d'exemple que crea sempre
les mateixes dades per tal de comprovar que la part que hem implementat del
\textit{frontend} funciona correctament, és a dir, tenim un sistema de fitxers
navegable.

Aquest exemple es troba a \texttt{backend/dummy/dummy.c}.


\subsubsection{El problema d'OpenMosix}

\nocite{OpenMosix-API}

El problema al que abans fèiem referència a l'apartat del \textit{frontend} és
el que ens hem trobat a l'hora de fer una implementació per a OpenMosix.

Bàsicament el problema és que OpenMosix ha estat pensat per a ser accedit sola i
exclusivament a través de la interfície que ofereix al directori
\texttt{/proc/hpc}, sense exportar cap símbol utilitzable des del propi nucli, de
forma que l'única manera d'accedir-hi és a través del VFS, el qual només és
accessible a través de programes amb un context propi (com serien programes en
mode usuari o threads de kernel).

Aquest intent d'implementació es troba a \texttt{backend/openmosix/}.

Algunes possibles solucions que no hem pogut implementar per falta de temps
serien:

\begin{itemize}
\item
Una solució que hem trobat sense haver de modificar ni el kernel ni el codi
d'OpenMosix, és, en tan bon punt s'activi el nostre sistema de fitxers, arrencar
un thread de kernel o programa en mode usuari (daemon) que esperi peticions
provinents del nostre \textit{backend}, moment en què aquest programa o thread
que duria a terme la petició a través de \texttt{/proc/hpc/} i retornaria el
resultat altra vegada al nostre \textit{backend} (veure la figura
\ref{fig:solucio-espai-usuari}).

\begin{figure}[hbtp]
   \centering
   \includegraphics[scale=0.3]{solucio-espai-usuari.eps}
   \caption{Esquema de la possible solució}
   \label{fig:solucio-espai-usuari}
\end{figure}

\item
Una altra solució molt menys elegant i més intrusiva seria exportar els símbols
de les funcions, dades i/o estructures que ens fessin falta del codi
d'OpenMosix, o bé afegir una part de codi propi que utilitzi el que hi ha a dins
d'OpenMosix i exportar aquestes funcions que ens proporcionarien just el que
volem, que seria com una extensió del nostre \textit{backend} que entraria a
dins del codi del kernel.
\\
A més a més aquestes dues últimes solucions no són molt viables pel fet de què la
documentació d'OpenMosix tant externa com a dins del propi codi és molt minsa.

\item
Una solució totalment circumstancial i depenent del binari seria la de conèixer
un símbol exportat a partir del que, donat un offset fixe i conegut, es pugui
accedir a la zona que ens interessa.
\end{itemize}

